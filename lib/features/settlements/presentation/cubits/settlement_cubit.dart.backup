import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/models/minimal_transfer.dart';
import '../../domain/repositories/settlement_repository.dart';
import 'settlement_state.dart';
import '../../../trips/presentation/cubits/trip_cubit.dart';
import '../../../trips/presentation/cubits/trip_state.dart';
import '../../../expenses/domain/repositories/expense_repository.dart';

/// Helper function to log with timestamps
void _log(String message) {
  debugPrint('[${DateTime.now().toIso8601String()}] [SettlementCubit] $message');
}

/// Cubit for managing settlement state
///
/// Handles loading and computing settlements for a trip
class SettlementCubit extends Cubit<SettlementState> {
  final SettlementRepository _settlementRepository;
  final TripCubit _tripCubit;
  final ExpenseRepository _expenseRepository;
  StreamSubscription? _summarySubscription;
  StreamSubscription? _transfersSubscription;
  StreamSubscription<TripState>? _tripSubscription;
  StreamSubscription? _expenseSubscription;
  String? _currentTripId;
  DateTime? _lastProcessedExpenseTimestamp;
  Set<String> _lastExpenseFingerprint = {};

  SettlementCubit({
    required SettlementRepository settlementRepository,
    required TripCubit tripCubit,
    required ExpenseRepository expenseRepository,
  })  : _settlementRepository = settlementRepository,
        _tripCubit = tripCubit,
        _expenseRepository = expenseRepository,
        super(const SettlementInitial());

  /// Separate transfers into active and settled lists
  ({List<MinimalTransfer> active, List<MinimalTransfer> settled}) _separateTransfers(
      List<MinimalTransfer> allTransfers) {
    final active = <MinimalTransfer>[];
    final settled = <MinimalTransfer>[];

    for (final transfer in allTransfers) {
      if (transfer.isSettled) {
        settled.add(transfer);
      } else {
        active.add(transfer);
      }
    }

    return (active: active, settled: settled);
  }

  /// Start watching the selected trip for expense changes
  ///
  /// Subscribes to TripCubit stream and triggers settlement recalculation
  /// when expenses are modified (detected via lastExpenseModifiedAt timestamp)
  void _watchSelectedTripForExpenseChanges() {
    _tripSubscription?.cancel();

    _tripSubscription = _tripCubit.stream.listen((tripState) {
      if (tripState is TripLoaded && tripState.selectedTrip != null) {
        final trip = tripState.selectedTrip!;

        // Only react if this is the trip we're currently tracking
        if (_currentTripId == trip.id) {
          _handleExpenseTimestampChange(trip);
        }
      }
    });

    _log('üëÄ Started watching trip for expense changes');
  }

  /// Handle changes to the expense timestamp
  ///
  /// Compares the new timestamp with the last processed one and triggers
  /// smart refresh if expenses have been modified
  void _handleExpenseTimestampChange(dynamic trip) {
    final newTimestamp = trip.lastExpenseModifiedAt as DateTime?;

    if (_shouldRefreshForTimestamp(newTimestamp)) {
      _lastProcessedExpenseTimestamp = newTimestamp;
      _log('üîÑ Expense timestamp changed to $newTimestamp, triggering smart refresh');
      smartRefresh(trip.id as String);
    }
  }

  /// Check if we should refresh based on timestamp comparison
  ///
  /// Returns true if the new timestamp indicates expenses have changed
  bool _shouldRefreshForTimestamp(DateTime? newTimestamp) {
    // No timestamp = no expenses yet
    if (newTimestamp == null) return false;

    // First time seeing a timestamp = should refresh
    if (_lastProcessedExpenseTimestamp == null) return true;

    // Timestamp advanced = expenses changed
    return newTimestamp.isAfter(_lastProcessedExpenseTimestamp!);
  }

  /// Watch expenses directly for changes (Layer 2 defense)
  ///
  /// Subscribes to expense collection and triggers recalculation when
  /// the set of expense IDs changes. This provides a fallback trigger
  /// mechanism independent of the trip timestamp watching.
  void _watchExpensesForChanges(String tripId) {
    _expenseSubscription?.cancel();

    _expenseSubscription = _expenseRepository
        .getExpensesByTrip(tripId)
        .listen(
      (expenses) {
        // Create fingerprint from expense IDs
        final newFingerprint = expenses.map((e) => e.id).toSet();

        // Check if fingerprint changed
        if (_lastExpenseFingerprint.isEmpty) {
          // First load, just store fingerprint
          _lastExpenseFingerprint = newFingerprint;
          _log('üìç Stored initial expense fingerprint: ${newFingerprint.length} expenses');
        } else if (!_setEquals(_lastExpenseFingerprint, newFingerprint)) {
          // Fingerprint changed - expenses added/deleted/modified
          _log('üîÑ Expense fingerprint changed (${_lastExpenseFingerprint.length} -> ${newFingerprint.length}), triggering smart refresh');
          _lastExpenseFingerprint = newFingerprint;
          smartRefresh(tripId);
        }
      },
      onError: (error) {
        _log('‚ùå Error watching expenses: $error');
      },
    );

    _log('üëÄ Started watching expenses directly for changes');
  }

  /// Check if two sets are equal
  bool _setEquals<T>(Set<T> set1, Set<T> set2) {
    if (set1.length != set2.length) return false;
    return set1.containsAll(set2);
  }

  /// Load settlement for a trip
  ///
  /// Subscribes to real-time updates for both summary and transfers
  Future<void> loadSettlement(String tripId) async {
    try {
      _log('üì• Loading settlement for trip: $tripId');
      _currentTripId = tripId;
      _lastProcessedExpenseTimestamp = null; // Reset timestamp tracker for new trip
      _lastExpenseFingerprint = {}; // Reset expense fingerprint for new trip

      // Cancel existing subscriptions
      await _summarySubscription?.cancel();
      await _transfersSubscription?.cancel();

      // Start watching trip for expense changes (Layer 1)
      _watchSelectedTripForExpenseChanges();

      // Start watching expenses directly for changes (Layer 2 - fallback)
      _watchExpensesForChanges(tripId);

      emit(const SettlementLoading());

      // Check if settlement exists
      final exists = await _settlementRepository.settlementExists(tripId);

      if (!exists) {
        _log('‚ö†Ô∏è Settlement does not exist, computing...');
        await computeSettlement(tripId);
        return;
      }

      // Subscribe to settlement summary stream
      _summarySubscription = _settlementRepository
          .watchSettlementSummary(tripId)
          .listen(
        (summary) async {
          if (summary == null) {
            _log('‚ö†Ô∏è Settlement summary became null, recomputing...');
            await computeSettlement(tripId);
            return;
          }

          _log('üì¶ Received settlement summary');
          _log('   Base Currency: ${summary.baseCurrency.code}');
          _log('   Last Computed: ${summary.lastComputedAt}');
          _log('   Person Summaries: ${summary.personSummaries.length} people');

          summary.personSummaries.forEach((userId, personSummary) {
            _log('   ‚Ä¢ $userId: Paid=${personSummary.totalPaidBase}, Owed=${personSummary.totalOwedBase}, Net=${personSummary.netBase}');
          });

          // Get transfers
          final allTransfers = await _settlementRepository
              .getMinimalTransfers(tripId)
              .first;

          _log('üì¶ Received ${allTransfers.length} minimal transfers');
          for (final transfer in allTransfers) {
            final status = transfer.isSettled ? '‚úÖ SETTLED' : '‚è≥ PENDING';
            _log('   ‚Ä¢ ${transfer.fromUserId} ‚Üí ${transfer.toUserId}: ${transfer.amountBase} $status');
          }

          // Separate active and settled transfers
          final separated = _separateTransfers(allTransfers);
          _log('üìä ${separated.active.length} active, ${separated.settled.length} settled');

          if (!isClosed) {
            emit(SettlementLoaded(
              summary: summary,
              activeTransfers: separated.active,
              settledTransfers: separated.settled,
            ));
          }
        },
        onError: (error) {
          _log('‚ùå Error loading settlement: $error');
          if (!isClosed) {
            emit(SettlementError('Failed to load settlement: ${error.toString()}'));
          }
        },
      );

      // Also subscribe to transfers for real-time updates
      _transfersSubscription = _settlementRepository
          .getMinimalTransfers(tripId)
          .listen(
        (allTransfers) {
          _log('üì¶ Transfers updated: ${allTransfers.length} transfers');
          if (state is SettlementLoaded && !isClosed) {
            final currentState = state as SettlementLoaded;
            final separated = _separateTransfers(allTransfers);
            _log('üìä ${separated.active.length} active, ${separated.settled.length} settled');
            emit(currentState.copyWith(
              activeTransfers: separated.active,
              settledTransfers: separated.settled,
            ));
          }
        },
        onError: (error) {
          _log('‚ùå Error loading transfers: $error');
        },
      );
    } catch (e) {
      _log('‚ùå Error in loadSettlement: $e');
      if (!isClosed) {
        emit(SettlementError('Failed to load settlement: ${e.toString()}'));
      }
    }
  }

  /// Compute settlement for a trip
  ///
  /// Calculates person summaries and minimal transfers from expenses
  /// This can be triggered manually or automatically when expenses change
  Future<void> computeSettlement(String tripId) async {
    try {
      _log('üîÑ Computing settlement for trip: $tripId');
      emit(const SettlementComputing());

      final summary = await _settlementRepository.computeSettlement(tripId);
      _log('‚úÖ Settlement computed successfully');

      // Get the computed transfers
      final allTransfers = await _settlementRepository
          .getMinimalTransfers(tripId)
          .first;

      // Separate active and settled transfers
      final separated = _separateTransfers(allTransfers);
      _log('üìä ${separated.active.length} active, ${separated.settled.length} settled');

      if (!isClosed) {
        emit(SettlementLoaded(
          summary: summary,
          activeTransfers: separated.active,
          settledTransfers: separated.settled,
        ));
      }

      // Now subscribe to real-time updates
      if (_currentTripId == tripId) {
        await loadSettlement(tripId);
      }
    } catch (e) {
      _log('‚ùå Error computing settlement: $e');
      if (!isClosed) {
        emit(SettlementError('Failed to compute settlement: ${e.toString()}'));
      }
    }
  }

  /// Refresh settlement data
  ///
  /// Re-computes the settlement from current expenses
  Future<void> refreshSettlement() async {
    if (_currentTripId != null) {
      await computeSettlement(_currentTripId!);
    }
  }

  /// Mark a specific transfer as settled
  ///
  /// Updates the transfer in Firestore, which will trigger real-time update
  Future<void> markTransferAsSettled(String transferId) async {
    if (_currentTripId == null) {
      _log('‚ö†Ô∏è Cannot mark transfer as settled: no current trip');
      return;
    }

    try {
      _log('‚úÖ Marking transfer $transferId as settled');
      await _settlementRepository.markTransferAsSettled(_currentTripId!, transferId);
      _log('‚úÖ Transfer marked as settled');
      // Real-time listener will automatically update the UI
    } catch (e) {
      _log('‚ùå Error marking transfer as settled: $e');
      if (!isClosed) {
        emit(SettlementError('Failed to mark transfer as settled: ${e.toString()}'));
      }
    }
  }

  /// Smart refresh: only recompute if expenses have changed
  ///
  /// Checks if expenses were modified after settlement was last computed
  /// If yes, recomputes settlement. Otherwise, just reloads existing data.
  /// Always reloads settlement data to ensure UI shows latest state (e.g., settled transfers).
  Future<void> smartRefresh(String tripId) async {
    try {
      _log('üîç Smart refresh check for trip: $tripId');

      final shouldRecompute = await _settlementRepository.shouldRecompute(tripId);

      if (shouldRecompute) {
        _log('üîÑ Expenses changed, recomputing settlement');
        await computeSettlement(tripId);
      } else {
        _log('‚úÖ Settlement is up-to-date, reloading from Firestore');
        // Always reload to get latest data (e.g., settled transfers)
        await loadSettlement(tripId);
      }
    } catch (e) {
      _log('‚ùå Error in smart refresh: $e');
      if (!isClosed) {
        emit(SettlementError('Failed to refresh settlement: ${e.toString()}'));
      }
    }
  }

  /// Get current trip ID
  String? get currentTripId => _currentTripId;

  @override
  Future<void> close() {
    _log('üî¥ Closing SettlementCubit - cancelling subscriptions');
    _summarySubscription?.cancel();
    _transfersSubscription?.cancel();
    _tripSubscription?.cancel();
    _expenseSubscription?.cancel();
    return super.close();
  }
}
