import 'dart:convert';
import 'package:build/build.dart';

/// Builder factory for currency code generation
Builder currencyCodeBuilder(BuilderOptions options) {
  return _CurrencyCodeBuilder();
}

class _CurrencyCodeBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => const {
        '.dart': ['.g.dart']
      };

  @override
  Future<void> build(BuildStep buildStep) async {
    final inputId = buildStep.inputId;

    // Only generate for currency_code.dart
    if (!inputId.path.endsWith('lib/core/models/currency_code.dart')) {
      return;
    }

    try {
      // Read the currencies.json asset
      final currenciesAsset = AssetId(inputId.package, 'assets/currencies.json');
      final jsonString = await buildStep.readAsString(currenciesAsset);
      final jsonData = json.decode(jsonString) as Map<String, dynamic>;

      // Parse currencies
      final currenciesList = (jsonData['currencies'] as List)
          .cast<Map<String, dynamic>>();

      // Validate and generate code
      final generator = CurrencyCodeGenerator();
      final generatedCode = generator.generate(currenciesList);

      // Write generated code
      final outputId = inputId.changeExtension('.g.dart');
      await buildStep.writeAsString(outputId, generatedCode);
    } catch (e) {
      throw BuildStepException('Failed to generate currency code: $e');
    }
  }
}

/// Generator for currency code enum from JSON data
class CurrencyCodeGenerator {
  /// Dart reserved keywords that need to be escaped
  static const _reservedKeywords = {
    'assert', 'break', 'case', 'catch', 'class', 'const', 'continue',
    'default', 'do', 'else', 'enum', 'extends', 'false', 'final',
    'finally', 'for', 'if', 'in', 'is', 'new', 'null', 'rethrow',
    'return', 'super', 'switch', 'this', 'throw', 'true', 'try',
    'var', 'void', 'while', 'with'
  };

  /// Convert currency code to safe enum identifier
  String _toEnumName(String code) {
    final lowercase = code.toLowerCase();
    // Escape reserved keywords with $ prefix
    if (_reservedKeywords.contains(lowercase)) {
      return '\$$lowercase';
    }
    return lowercase;
  }

  /// Generate Dart code from currency data
  String generate(List<Map<String, dynamic>> currencies) {
    // Validate currencies
    _validateCurrencies(currencies);

    final buffer = StringBuffer();

    // Header
    buffer.writeln('//');
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by: CurrencyCodeGenerator');
    buffer.writeln('// Source: assets/currencies.json');
    buffer.writeln('// Generated at: ${DateTime.now().toUtc().toIso8601String()}');
    buffer.writeln('//');
    buffer.writeln();
    buffer.writeln("part of 'currency_code.dart';");
    buffer.writeln();

    // Generate enum
    buffer.writeln('/// ISO 4217 currency codes with metadata');
    buffer.writeln('///');
    buffer.writeln('/// This enum is generated from assets/currencies.json');
    buffer.writeln('/// To update: modify JSON file and run `dart run build_runner build`');
    buffer.writeln('enum CurrencyCode {');

    // Enum values
    for (var i = 0; i < currencies.length; i++) {
      final currency = currencies[i];
      final code = currency['code'] as String;
      final name = currency['name'] as String;
      final symbol = currency['symbol'] as String;
      final decimalPlaces = currency['decimalPlaces'] as int;

      final enumName = _toEnumName(code);
      buffer.writeln('  /// $name ($symbol, $decimalPlaces decimals)');
      buffer.write("  $enumName('$code', $decimalPlaces)");
      if (i < currencies.length - 1) {
        buffer.writeln(',');
      } else {
        buffer.writeln(';');
      }
      buffer.writeln();
    }

    // Enum constructor and fields
    buffer.writeln('  /// ISO 4217 alphabetic code (e.g., "USD", "EUR")');
    buffer.writeln('  final String code;');
    buffer.writeln();
    buffer.writeln('  /// Number of decimal places (minor units): 0, 2, or 3');
    buffer.writeln('  final int decimalPlaces;');
    buffer.writeln();
    buffer.writeln('  const CurrencyCode(this.code, this.decimalPlaces);');
    buffer.writeln();

    // fromString static method (in enum)
    buffer.writeln('  /// Parse currency code string to enum');
    buffer.writeln('  ///');
    buffer.writeln('  /// Returns null if code is invalid');
    buffer.writeln('  /// Case-insensitive matching');
    buffer.writeln('  static CurrencyCode? fromString(String? code) {');
    buffer.writeln('    if (code == null || code.isEmpty) return null;');
    buffer.writeln();
    buffer.writeln('    final normalized = code.trim().toUpperCase();');
    buffer.writeln();
    buffer.writeln('    switch (normalized) {');
    for (final currency in currencies) {
      final code = currency['code'] as String;
      final enumName = _toEnumName(code);
      buffer.writeln("      case '$code': return CurrencyCode.$enumName;");
    }
    buffer.writeln('      default: return null;');
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();

    // activeCurrencies static getter (in enum)
    buffer.writeln('  /// Get all active currencies (for currency picker)');
    buffer.writeln('  static List<CurrencyCode> get activeCurrencies {');
    buffer.writeln('    return CurrencyCode.values.where((c) => c.isActive).toList();');
    buffer.writeln('  }');

    buffer.writeln('}');
    buffer.writeln();

    // Extension methods
    buffer.writeln('/// Extension methods for CurrencyCode');
    buffer.writeln('extension CurrencyCodeExtension on CurrencyCode {');

    // Symbol getter
    buffer.writeln('  /// Currency symbol or code fallback');
    buffer.writeln('  String get symbol {');
    buffer.writeln('    switch (this) {');
    for (final currency in currencies) {
      final code = currency['code'] as String;
      final symbol = currency['symbol'] as String;
      final enumName = _toEnumName(code);

      // Escape special characters in symbol
      final escapedSymbol = symbol
          .replaceAll(r'\', r'\\')
          .replaceAll(r'$', r'\$')
          .replaceAll("'", r"\'");

      buffer.writeln("      case CurrencyCode.$enumName: return '$escapedSymbol';");
    }
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();

    // Display name getter
    buffer.writeln('  /// English display name');
    buffer.writeln('  String get displayName {');
    buffer.writeln('    switch (this) {');
    for (final currency in currencies) {
      final code = currency['code'] as String;
      final name = currency['name'] as String;
      final enumName = _toEnumName(code);

      // Escape apostrophes in names
      final escapedName = name.replaceAll("'", r"\'");

      buffer.writeln("      case CurrencyCode.$enumName: return '$escapedName';");
    }
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();

    // isActive getter
    buffer.writeln('  /// Whether currency is actively used');
    buffer.writeln('  bool get isActive {');
    buffer.writeln('    switch (this) {');

    // Group active and inactive
    final activeCurrencies = currencies.where((c) => c['active'] == true).toList();
    final inactiveCurrencies = currencies.where((c) => c['active'] != true).toList();

    // Active currencies
    for (final currency in activeCurrencies) {
      final code = currency['code'] as String;
      final enumName = _toEnumName(code);
      buffer.writeln('      case CurrencyCode.$enumName:');
    }
    buffer.writeln('        return true;');

    // Inactive currencies
    if (inactiveCurrencies.isNotEmpty) {
      for (final currency in inactiveCurrencies) {
        final code = currency['code'] as String;
        final enumName = _toEnumName(code);
        buffer.writeln('      case CurrencyCode.$enumName:');
      }
      buffer.writeln('        return false;');
    }

    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln('}');

    return buffer.toString();
  }

  /// Validate currency data
  void _validateCurrencies(List<Map<String, dynamic>> currencies) {
    final seenCodes = <String>{};

    for (var i = 0; i < currencies.length; i++) {
      final currency = currencies[i];

      // Required fields
      final code = currency['code'];
      final numericCode = currency['numericCode'];
      final name = currency['name'];
      final symbol = currency['symbol'];
      final decimalPlaces = currency['decimalPlaces'];
      final active = currency['active'];

      if (code == null) {
        throw ArgumentError('Currency at index $i missing required field: code');
      }
      if (numericCode == null) {
        throw ArgumentError('Currency at index $i missing required field: numericCode');
      }
      if (name == null) {
        throw ArgumentError('Currency at index $i missing required field: name');
      }
      if (symbol == null) {
        throw ArgumentError('Currency at index $i missing required field: symbol');
      }
      if (decimalPlaces == null) {
        throw ArgumentError('Currency at index $i missing required field: decimalPlaces');
      }
      if (active == null) {
        throw ArgumentError('Currency at index $i missing required field: active');
      }

      // Validate code format (3 uppercase letters)
      if (code is! String || !RegExp(r'^[A-Z]{3}$').hasMatch(code)) {
        throw ArgumentError('Invalid code format for currency at index $i: $code (must be 3 uppercase letters)');
      }

      // Validate numeric code format (3 digits)
      if (numericCode is! String || !RegExp(r'^\d{3}$').hasMatch(numericCode)) {
        throw ArgumentError('Invalid numericCode format for currency at index $i: $numericCode (must be 3 digits)');
      }

      // Validate decimal places (0, 2, or 3)
      if (decimalPlaces is! int || ![0, 2, 3].contains(decimalPlaces)) {
        throw ArgumentError('Invalid decimalPlaces for currency $code: $decimalPlaces (must be 0, 2, or 3)');
      }

      // Check for duplicates
      if (seenCodes.contains(code)) {
        throw ArgumentError('Duplicate currency code: $code');
      }
      seenCodes.add(code);

      // Validate name and symbol are non-empty
      if (name is! String || name.isEmpty) {
        throw ArgumentError('Invalid name for currency $code: name must be non-empty string');
      }
      if (symbol is! String || symbol.isEmpty) {
        throw ArgumentError('Invalid symbol for currency $code: symbol must be non-empty string');
      }

      // Validate active is boolean
      if (active is! bool) {
        throw ArgumentError('Invalid active field for currency $code: must be boolean');
      }
    }
  }
}

class BuildStepException implements Exception {
  final String message;
  BuildStepException(this.message);

  @override
  String toString() => message;
}
