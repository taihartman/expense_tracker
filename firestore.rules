rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Check if user is authenticated (anonymous or full auth)
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: Validate category name format
    function isValidCategoryName(name) {
      return name is string
          && name.size() >= 1
          && name.size() <= 50
          && name.matches('^[\\p{L}\\p{N}\\s\'\\-&]+$');
    }

    // TODO: Rate limiting and duplicate checking removed from security rules
    // because firestore.get() cannot query collections (only specific documents).
    // These validations are enforced client-side via RateLimiterService.
    // For production, implement server-side validation via Cloud Functions.

    // Helper: Check if user is a verified member of a trip
    function isVerifiedMember(tripId) {
      return exists(/databases/$(database)/documents/trips/$(tripId)/verifiedMembers/$(request.auth.uid));
    }

    // Global Categories: Top-level shared collection
    // Anyone can read, create with validation, but updates/deletes forbidden
    match /categories/{categoryId} {
      // Anyone can read categories
      allow read: if isAuthenticated();

      // Create with validation (rate limiting and duplicate checking handled client-side)
      allow create: if isAuthenticated()
                    && isValidCategoryName(request.resource.data.name);

      // Allow updates to:
      // - icon field (for voting system)
      // - usageCount (for tracking category popularity)
      // - updatedAt (timestamp for both operations)
      // All other fields are immutable to preserve expense references
      allow update: if isAuthenticated()
                    && request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['icon', 'usageCount', 'updatedAt'])
                    // If updating icon, validate it's a non-empty string
                    && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['icon'])
                        || (request.resource.data.icon is string
                            && request.resource.data.icon.size() > 0))
                    // If updating usageCount, ensure it only increments by 1
                    && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['usageCount'])
                        || request.resource.data.usageCount == resource.data.usageCount + 1);

      // No deletes (categories are permanent to preserve expense references)
      allow delete: if false;
    }

    // Category Icon Preferences: Voting system for crowd-sourced icon improvements
    // Tracks how many users have customized each category to use specific icons
    match /categoryIconPreferences/{preferenceId} {
      // Anyone can read preferences (to see vote counts and most popular icons)
      allow read: if isAuthenticated();

      // Allow creating/updating preferences (voting)
      // Validation: Must have valid structure and categoryId/iconName
      allow create, update: if isAuthenticated()
                            && request.resource.data.categoryId is string
                            && request.resource.data.categoryId.size() > 0
                            && request.resource.data.iconName is string
                            && request.resource.data.iconName.size() > 0
                            && request.resource.data.voteCount is int
                            && request.resource.data.voteCount >= 0
                            && request.resource.data.lastVoteAt is timestamp
                            && request.resource.data.mostPopular is bool;

      // No deletion (votes are permanent for audit trail)
      allow delete: if false;
    }

    // Category Creation Logs: Rate limiting tracking
    match /categoryCreationLogs/{logId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;

      // No updates or deletes
      allow update, delete: if false;
    }

    // Expenses: Top-level collection (read/write if authenticated AND verified member)
    // TODO: Move to subcollection under trips for better security and data isolation
    match /expenses/{expenseId} {
      // For reads: Check if user is verified member of the trip this expense belongs to
      allow read: if isAuthenticated()
                  && isVerifiedMember(resource.data.tripId);

      // For writes: Check if user is verified member of the trip
      allow create: if isAuthenticated()
                    && isVerifiedMember(request.resource.data.tripId);

      allow update, delete: if isAuthenticated()
                            && isVerifiedMember(resource.data.tripId);
    }

    // Settlements: Top-level collection for computed settlement data
    // Contains settlement summaries and minimal transfers for each trip
    match /settlements/{tripId} {
      // Allow reading settlement documents only if verified member
      allow read: if isAuthenticated()
                  && isVerifiedMember(tripId);

      // Allow writing settlement summaries and transfers only if verified member
      allow write: if isAuthenticated()
                   && isVerifiedMember(tripId);

      // Transfers subcollection
      match /transfers/{transferId} {
        allow read: if isAuthenticated()
                    && isVerifiedMember(tripId);
        allow write: if isAuthenticated()
                     && isVerifiedMember(tripId);
      }
    }

    // Settled Transfers: Top-level collection (read/write if verified member)
    // TODO: Move to subcollection under trips for better security and data isolation
    match /settledTransfers/{tripId}/transfers/{transferId} {
      allow read: if isAuthenticated()
                  && isVerifiedMember(tripId);

      // Allow creating/updating settled transfers with validation
      allow create, update: if isAuthenticated()
                            && isVerifiedMember(tripId)
                            && request.resource.data.tripId == tripId
                            && request.resource.data.fromUserId is string
                            && request.resource.data.fromUserId.size() > 0
                            && request.resource.data.toUserId is string
                            && request.resource.data.toUserId.size() > 0
                            && request.resource.data.amountBase is string
                            && request.resource.data.isSettled == true
                            && request.resource.data.settledAt is timestamp;

      // Allow deleting (unmarking) settled transfers
      allow delete: if isAuthenticated()
                    && isVerifiedMember(tripId);
    }

    // Trips: Create if authenticated, read/write if verified member
    match /trips/{tripId} {
      // Allow anyone to create a new trip
      allow create: if isAuthenticated();

      // Allow reading trip only if verified member
      allow read: if isAuthenticated()
                  && isVerifiedMember(tripId);

      // Allow updating/deleting trip only if verified member
      allow update, delete: if isAuthenticated()
                            && isVerifiedMember(tripId);

      // Activity Log: Append-only audit trail (verified members only)
      match /activityLog/{logId} {
        // Only verified members can read activity logs
        allow read: if isAuthenticated()
                    && isVerifiedMember(tripId);

        // Only allow creating new logs (no updates or deletes to preserve audit trail)
        allow create: if isAuthenticated()
                      && isVerifiedMember(tripId)
                      && request.resource.data.timestamp == request.time
                      && request.resource.data.tripId == tripId;

        // Deny updates and deletes to maintain log integrity
        allow update, delete: if false;
      }

      // Device Link Codes: Temporary codes for device pairing
      match /deviceLinkCodes/{codeId} {
        // Anyone authenticated can read codes to validate them during pairing
        // (brute force should be protected by rate limiting - TODO: add server-side)
        allow read: if isAuthenticated();

        // Only verified members can create codes
        allow create: if isAuthenticated()
                      && isVerifiedMember(tripId)
                      && request.resource.data.code.size() == 9  // "XXXX-XXXX"
                      && request.resource.data.memberName.size() > 0
                      && request.resource.data.used == false
                      && request.resource.data.expiresAt > request.time
                      && request.resource.data.expiresAt <= request.time + duration.value(20, 'm'); // Max 20 min expiry

        // Anyone can mark code as used during pairing (one-way state change)
        allow update: if isAuthenticated()
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['used', 'usedAt'])
                      && request.resource.data.used == true
                      && resource.data.used == false;

        // Only verified members can delete (revoke codes)
        allow delete: if isAuthenticated()
                      && isVerifiedMember(tripId);
      }

      // Validation Attempts: Rate limiting tracking
      match /validationAttempts/{attemptId} {
        // Anyone can read to check rate limits
        allow read: if isAuthenticated();

        // Anyone can create attempt records
        allow create: if isAuthenticated()
                      && request.resource.data.timestamp == request.time;

        // No updates or deletes (cleanup happens client-side or via TTL)
        allow update, delete: if false;
      }

      // Recovery Code: Single document for emergency trip access
      match /recovery/code {
        // Anyone authenticated can read recovery code (needed for validation during join)
        allow read: if isAuthenticated();

        // Only verified members can create a recovery code for a trip
        allow create: if isAuthenticated()
                      && isVerifiedMember(tripId)
                      && request.resource.data.code is string
                      && request.resource.data.code.size() == 14  // "XXXX-XXXX-XXXX"
                      && request.resource.data.tripId == tripId
                      && request.resource.data.createdAt is timestamp
                      && request.resource.data.usedCount is int
                      && request.resource.data.usedCount >= 0
                      // lastUsedAt can be null on creation
                      && (!request.resource.data.keys().hasAny(['lastUsedAt']) || request.resource.data.lastUsedAt == null || request.resource.data.lastUsedAt is timestamp);

        // Anyone can update usage count during join (before becoming verified member)
        allow update: if isAuthenticated()
                      && request.resource.data.code == resource.data.code  // Code cannot change
                      && request.resource.data.tripId == resource.data.tripId  // Trip ID cannot change
                      && request.resource.data.usedCount == resource.data.usedCount + 1  // Can only increment by 1
                      && request.resource.data.lastUsedAt is timestamp;

        // Only verified members can delete (regenerate)
        allow delete: if isAuthenticated()
                      && isVerifiedMember(tripId);
      }

      // Verified Members: Track who has actually joined the trip
      // Document ID is Firebase Auth UID, data contains participantId/participantName
      match /verifiedMembers/{authUid} {
        // Anyone authenticated can read verified members (needed for join flow and invite messages)
        allow read: if isAuthenticated();

        // Anyone can add themselves as a verified member during join/device pairing
        // This is the bootstrap mechanism - users must be able to add themselves to verifiedMembers
        // even before they are verified members (chicken-and-egg problem)
        // CRITICAL: Document ID must match current user's auth UID
        allow create: if isAuthenticated()
                      && authUid == request.auth.uid  // Can only add yourself
                      && request.resource.data.participantId is string
                      && request.resource.data.participantId.size() > 0
                      && request.resource.data.participantName is string
                      && request.resource.data.participantName.size() > 0
                      && request.resource.data.verifiedAt is timestamp;

        // Allow updating verification timestamp (re-verification)
        // User can only update their own verified member record
        allow update: if isAuthenticated()
                      && authUid == request.auth.uid
                      && request.resource.data.participantId == resource.data.participantId
                      && request.resource.data.participantName == resource.data.participantName;

        // Allow users to leave (remove their own verification)
        allow delete: if isAuthenticated()
                      && authUid == request.auth.uid;
      }

      // Category Customizations: Per-trip visual overrides for global categories
      // Allows trips to customize icon and color for any category
      match /categoryCustomizations/{categoryId} {
        // Allow reading customizations only for verified members
        allow read: if isAuthenticated()
                    && isVerifiedMember(tripId);

        // Allow creating/updating customizations only for verified members
        // Validation: Must have valid icon or color, and updatedAt timestamp
        allow create, update: if isAuthenticated()
                              && isVerifiedMember(tripId)
                              && request.resource.data.tripId == tripId
                              && request.resource.data.updatedAt is timestamp
                              && (
                                // Must have at least one customization (icon or color)
                                request.resource.data.keys().hasAny(['customIcon', 'customColor'])
                              );

        // Allow deleting customizations (reset to global defaults) for verified members
        allow delete: if isAuthenticated()
                      && isVerifiedMember(tripId);
      }

      // Other trip subcollections: Inherit trip membership requirements
      match /{document=**} {
        allow read, write: if isAuthenticated()
                           && isVerifiedMember(tripId);
      }

      // Computed data: Read-only for verified members (Cloud Functions write)
      match /computed/{document=**} {
        allow read: if isAuthenticated()
                    && isVerifiedMember(tripId);
        allow write: if false;  // Only server can write
      }
    }
  }
}