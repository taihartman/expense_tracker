# Phase 1: Data Model - Device Pairing

**Feature**: Device Pairing for Multi-Device Access
**Branch**: `004-device-pairing`
**Date**: 2025-10-29

## Purpose

This document defines the complete data model for device pairing, including entity schemas, Firestore collections, validation rules, and data flow diagrams.

---

## Entity Definitions

### DeviceLinkCode

Represents a temporary verification code generated by an existing member to grant trip access to a requesting user on a new device.

**Domain Entity** (Dart):

```dart
class DeviceLinkCode {
  final String id;              // Firestore auto-generated document ID
  final String code;            // 8-digit string (e.g., "1234-5678")
  final String tripId;          // Which trip this grants access to
  final String memberName;      // Member name this code was generated FOR (original casing)
  final DateTime createdAt;     // When code was generated
  final DateTime expiresAt;     // When code becomes invalid (createdAt + 15 minutes)
  final bool used;              // Whether code has been used
  final DateTime? usedAt;       // When code was used (null if unused)

  const DeviceLinkCode({
    required this.id,
    required this.code,
    required this.tripId,
    required this.memberName,
    required this.createdAt,
    required this.expiresAt,
    required this.used,
    this.usedAt,
  });

  // Validation
  String? validate() {
    if (code.length != 9) { // 8 digits + 1 hyphen
      return 'Code must be 8 digits in format XXXX-XXXX';
    }
    if (tripId.isEmpty) {
      return 'Trip ID is required';
    }
    if (memberName.isEmpty) {
      return 'Member name is required';
    }
    if (expiresAt.isBefore(createdAt)) {
      return 'Expiry time must be after creation time';
    }
    if (used && usedAt == null) {
      return 'Used codes must have usedAt timestamp';
    }
    return null; // Valid
  }

  // Business logic
  bool get isExpired => DateTime.now().isAfter(expiresAt);
  bool get isValid => !used && !isExpired;
  Duration get timeUntilExpiry => expiresAt.difference(DateTime.now());
}
```

---

## Firestore Schema

### Collection Structure

```
/trips/{tripId}/deviceLinkCodes/{autoId}
```

**Why Subcollection?**
- Scopes codes to specific trips (natural organization)
- Enables efficient queries by tripId
- Simplifies security rules (can reference parent trip)
- Auto-cleanup easier (delete all codes when trip deleted)

### Document Schema

**Path**: `/trips/{tripId}/deviceLinkCodes/{autoId}`

```json
{
  "code": "1234-5678",
  "memberName": "Alice",
  "memberNameLower": "alice",
  "tripId": "trip123",
  "createdAt": Timestamp(2025-10-29T10:00:00Z),
  "expiresAt": Timestamp(2025-10-29T10:15:00Z),
  "used": false,
  "usedAt": null
}
```

**Field Details**:

| Field | Type | Required | Description | Constraints |
|-------|------|----------|-------------|-------------|
| `code` | string | ✅ | 8-digit code with hyphen | Format: `XXXX-XXXX`, unique per trip |
| `memberName` | string | ✅ | Original member name (preserves casing) | 1-50 characters |
| `memberNameLower` | string | ✅ | Lowercase version for case-insensitive queries | Auto-generated from memberName |
| `tripId` | string | ✅ | Reference to parent trip | Must exist in `/trips/{tripId}` |
| `createdAt` | Timestamp | ✅ | Server timestamp when code created | Auto-set via `FieldValue.serverTimestamp()` |
| `expiresAt` | Timestamp | ✅ | When code becomes invalid | Always `createdAt + 15 minutes` |
| `used` | boolean | ✅ | Whether code has been used | Default: `false` |
| `usedAt` | Timestamp | ❌ | When code was used | `null` until used, then server timestamp |

**Indexes Required**:
```
Collection: deviceLinkCodes
- Composite index: (tripId ASC, code ASC)
- Composite index: (tripId ASC, memberNameLower ASC, used ASC, expiresAt DESC)
- Composite index: (tripId ASC, expiresAt ASC) [for cleanup queries]
```

---

## Firestore Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Device Link Codes subcollection
    match /trips/{tripId}/deviceLinkCodes/{codeId} {

      // Anyone can read codes to validate them
      // Note: Code values are not secret (brute force protected by rate limiting)
      allow read: if request.auth != null
        && exists(/databases/$(database)/documents/trips/$(tripId));

      // Only trip members can create codes
      allow create: if request.auth != null
        && exists(/databases/$(database)/documents/trips/$(tripId))
        && request.resource.data.code.size() == 9  // "XXXX-XXXX"
        && request.resource.data.memberName.size() > 0
        && request.resource.data.used == false
        && request.resource.data.expiresAt > request.time
        && request.resource.data.expiresAt <= request.time + duration.value(20, 'm'); // Max 20 min expiry

      // Only system can update (mark as used)
      // Note: In production, use Cloud Function for this. For MVP, allow authenticated updates.
      allow update: if request.auth != null
        && exists(/databases/$(database)/documents/trips/$(tripId))
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['used', 'usedAt'])
        && request.resource.data.used == true
        && resource.data.used == false;  // Can only transition from unused to used

      // Only trip members can delete (revoke codes)
      allow delete: if request.auth != null
        && exists(/databases/$(database)/documents/trips/$(tripId));
    }
  }
}
```

**Security Analysis**:
- ✅ Prevents non-members from generating codes
- ✅ Prevents modification of code value after creation
- ✅ Prevents marking code as unused after use (one-way state change)
- ✅ Rate limiting enforced at application level (not in rules for MVP)
- ✅ Expired codes can still be read (validation happens in application)

---

## Data Flow Diagrams

### Flow 1: Code Generation (Happy Path)

```
[Device A - Existing Member]
  │
  ├─ 1. User taps member "Alice" in trip members list
  │
  ├─ 2. User clicks "Generate Code" button
  │     └─> DevicePairingCubit.generateCode(tripId: "trip123", memberName: "Alice")
  │
  ├─ 3. Cubit generates secure 8-digit code
  │     └─> CodeGenerator.generateCode() → "1234-5678"
  │
  ├─ 4. Cubit creates Firestore document
  │     └─> POST /trips/trip123/deviceLinkCodes/
  │          {
  │            code: "1234-5678",
  │            memberName: "Alice",
  │            memberNameLower: "alice",
  │            tripId: "trip123",
  │            createdAt: serverTimestamp(),
  │            expiresAt: now() + 15 minutes,
  │            used: false
  │          }
  │
  ├─ 5. Cubit emits CodeGenerated state with code
  │     └─> CodeGenerationDialog displays code with copy button
  │
  └─ 6. User copies code and shares with Device B user
```

---

### Flow 2: Code Validation (Happy Path)

```
[Device B - New Device]
  │
  ├─ 1. User tries to join trip with name "Alice"
  │     └─> TripJoinPage.submitJoinForm(tripId: "trip123", name: "Alice")
  │
  ├─ 2. TripCubit detects duplicate name (case-insensitive)
  │     └─> Trip.participants contains "alice" (lowercase match)
  │
  ├─ 3. System shows CodeVerificationPrompt dialog
  │     └─> User enters code: "1234-5678" (or "12345678")
  │
  ├─ 4. User submits code
  │     └─> DevicePairingCubit.validateCode(
  │          tripId: "trip123",
  │          code: "12345678",  // Normalized (hyphen removed)
  │          memberName: "Alice"
  │        )
  │
  ├─ 5. Cubit queries Firestore for matching code
  │     └─> GET /trips/trip123/deviceLinkCodes
  │          WHERE code == "1234-5678"
  │          WHERE memberNameLower == "alice"
  │          WHERE used == false
  │          WHERE expiresAt > now()
  │          LIMIT 1
  │
  ├─ 6. Cubit validates code in Firestore transaction
  │     └─> TRANSACTION {
  │          READ codeDoc
  │          VALIDATE: not used, not expired, name matches
  │          UPDATE codeDoc { used: true, usedAt: serverTimestamp() }
  │        }
  │
  ├─ 7. On success, cubit grants trip access
  │     └─> Save tripId to SharedPreferences
  │     └─> Navigate to trip page
  │
  └─ 8. Cubit emits CodeValidated state
        └─> Show success message: "Device verified!"
```

---

### Flow 3: Code Validation (Error Cases)

```
[Device B - Error Scenarios]

┌─ Invalid Code
│  └─> Code not found in Firestore
│      → Error: "Invalid or expired code"
│
┌─ Expired Code
│  └─> expiresAt < now()
│      → Error: "Code has expired. Request a new one from a member."
│
┌─ Already Used
│  └─> used == true
│      → Error: "Code already used"
│
┌─ Wrong Member Name
│  └─> memberNameLower != inputName.toLowerCase()
│      → Error: "Code doesn't match your member name"
│
└─ Rate Limited
   └─> >5 attempts in last 60 seconds
       → Error: "Too many attempts. Please wait 60 seconds."
```

---

## Data Lifecycle

### Code Generation
1. **Create**: Member generates code → Firestore document created
2. **Active**: Code is valid for 15 minutes
3. **Used**: Code validated successfully → `used` set to `true`, `usedAt` recorded
4. **Expired**: 15 minutes pass → Code no longer valid (checked in application)
5. **Cleanup**: After 24 hours → Document optionally deleted (client-side cleanup)

### State Transitions

```
     [Created]
        │
        ├─→ [Expired] (after 15 min) → [Cleanup] (after 24 hours)
        │
        └─→ [Used] → [Cleanup] (after 24 hours)
```

**State Rules**:
- Used codes cannot become unused (one-way transition)
- Expired codes can still be used if validation happens before expiry check
- Codes can be revoked (deleted) by trip members at any time

---

## Validation Attempts Tracking (Rate Limiting)

### Subcollection Structure

```
/trips/{tripId}/validationAttempts/{autoId}
```

### Document Schema

```json
{
  "timestamp": Timestamp(2025-10-29T10:05:30Z),
  "success": false,
  "codeAttempted": "1234****" // Last 4 digits masked for privacy
}
```

**Usage**:
- Created on each validation attempt
- Used to count recent attempts (last 60 seconds)
- Cleaned up after 1 hour (TTL or client-side cleanup)

---

## Integration with Existing Entities

### Trip Entity (No Schema Changes)

The `Trip` entity remains unchanged. Device pairing integrates via:

```dart
// Existing Trip entity
class Trip {
  final String id;
  final List<Participant> participants;  // Used for duplicate detection
  // ... other fields
}

// Integration point
bool hasDuplicateMember(String name) {
  return participants.any(
    (p) => p.name.toLowerCase() == name.toLowerCase()
  );
}
```

### Participant Entity (No Schema Changes)

The `Participant` entity remains unchanged. Device pairing uses existing participant data:

```dart
class Participant {
  final String id;
  final String name;  // Used for case-insensitive matching
  // ... other fields
}
```

---

## Query Patterns

### Find Active Code for Member

```dart
final codesQuery = await _firestore
  .collection('trips')
  .doc(tripId)
  .collection('deviceLinkCodes')
  .where('memberNameLower', isEqualTo: memberName.toLowerCase())
  .where('used', isEqualTo: false)
  .where('expiresAt', isGreaterThan: Timestamp.now())
  .limit(1)
  .get();
```

### Count Recent Validation Attempts

```dart
final cutoff = DateTime.now().subtract(Duration(seconds: 60));
final attemptsQuery = await _firestore
  .collection('trips')
  .doc(tripId)
  .collection('validationAttempts')
  .where('timestamp', isGreaterThan: Timestamp.fromDate(cutoff))
  .get();

final attemptCount = attemptsQuery.docs.length;
```

### List All Active Codes for Trip

```dart
final activeCodesQuery = await _firestore
  .collection('trips')
  .doc(tripId)
  .collection('deviceLinkCodes')
  .where('used', isEqualTo: false)
  .where('expiresAt', isGreaterThan: Timestamp.now())
  .orderBy('expiresAt', descending: true)
  .get();
```

---

## Data Migration

**Required**: None - This is a new feature with new collections. No existing data needs migration.

**Firestore Indexes**: Will be auto-created when first queries execute. If errors occur, add indexes manually via Firebase Console:

```
Collection: deviceLinkCodes (collection group)
Fields: tripId (Ascending), code (Ascending)
Query Scope: Collection Group

Collection: deviceLinkCodes (collection group)
Fields: tripId (Ascending), memberNameLower (Ascending), used (Ascending), expiresAt (Descending)
Query Scope: Collection Group
```

---

## Storage Estimates

**Per Code**: ~200 bytes
- code: 10 bytes
- memberName: 20 bytes (avg)
- memberNameLower: 20 bytes
- tripId: 28 bytes
- timestamps: 64 bytes (4 × 16 bytes)
- metadata: ~58 bytes

**Expected Usage**:
- 1000 users × 2 devices × 1 code/week = 2000 codes/week
- 2000 codes × 200 bytes = 400 KB/week
- Annual: ~20 MB (negligible)

**Firestore Operations**:
- Generate code: 1 write
- Validate code: 1 read + 1 write (transaction) = 2 read + 1 write total
- Per 1000 validations/day: 2000 reads + 1000 writes (well within free tier)

---

## Next Steps

Proceed to generate **contracts/** directory with API specifications for code generation and validation operations.
