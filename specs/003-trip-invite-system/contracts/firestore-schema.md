# Firestore Schema: Trip Invite System

**Version**: 1.0.0
**Date**: 2025-10-28
**Purpose**: Define Firestore collections, documents, indexes, and security rules for trip invite system

## Collection Structure

### Existing Collections (No Changes)

```
/trips/{tripId}
/expenses/{expenseId}
/categories/{categoryId}
/exchangeRates/{rateId}
/settlementSummaries/{summaryId}
/pairwiseDebts/{debtId}
/minimalTransfers/{transferId}
```

### New Subcollection

```
/trips/{tripId}/activityLog/{logId}
```

---

## Document Schemas

### 1. ActivityLog Document

**Path**: `/trips/{tripId}/activityLog/{logId}`

**Schema**:
```typescript
{
  "actorName": string,           // Required: 1-50 chars
  "type": string,                // Required: One of ActivityType enum values
  "description": string,         // Required: 1-200 chars, human-readable
  "timestamp": Timestamp,        // Required: Server timestamp
  "metadata": {                  // Optional: Action-specific data
    [key: string]: any
  }
}
```

**Example Documents**:

```json
// Member joined
{
  "actorName": "Tai",
  "type": "member_joined",
  "description": "Tai joined the trip",
  "timestamp": Timestamp(2025-10-28T14:30:00Z),
  "metadata": null
}

// Expense added
{
  "actorName": "Khiet",
  "type": "expense_added",
  "description": "Khiet added expense 'Dinner at Pho 24'",
  "timestamp": Timestamp(2025-10-28T18:45:00Z),
  "metadata": {
    "expenseId": "exp123abc",
    "amount": 250000,
    "currency": "VND",
    "title": "Dinner at Pho 24"
  }
}

// Expense edited
{
  "actorName": "Bob",
  "type": "expense_edited",
  "description": "Bob edited expense 'Taxi to airport'",
  "timestamp": Timestamp(2025-10-28T20:15:00Z),
  "metadata": {
    "expenseId": "exp456def",
    "changes": ["amount", "description"]
  }
}

// Expense deleted
{
  "actorName": "Ethan",
  "type": "expense_deleted",
  "description": "Ethan deleted expense 'Hotel booking'",
  "timestamp": Timestamp(2025-10-29T09:00:00Z),
  "metadata": {
    "expenseId": "exp789xyz",
    "amount": 1500000,
    "title": "Hotel booking"
  }
}
```

**Field Constraints**:
- `actorName`: Must match a participant name in parent trip (soft constraint)
- `type`: Must be one of: `trip_created`, `member_joined`, `expense_added`, `expense_edited`, `expense_deleted`, `settlement_calculated`
- `description`: Auto-generated from template, not user-entered
- `timestamp`: Server-side timestamp (not client-provided)
- `metadata`: Optional, varies by type (no fixed schema)

---

### 2. Trip Document (Existing - Membership Semantics)

**Path**: `/trips/{tripId}`

**Existing Schema** (Unchanged):
```typescript
{
  "name": string,
  "baseCurrency": string,  // "USD" | "VND"
  "createdAt": Timestamp,
  "updatedAt": Timestamp,
  "lastExpenseModifiedAt": Timestamp | null,
  "participants": [         // NOW USED FOR MEMBERSHIP
    {
      "id": string,         // e.g., "tai", "khiet"
      "name": string,       // e.g., "Tai", "Khiet"
      "createdAt": Timestamp
    }
  ]
}
```

**New Membership Semantics**:
- **Empty `participants` array**: Trip not yet claimed (legacy/new unclaimed trip)
- **Non-empty `participants` array**: List of users who can access trip
- **Invite code**: Trip document ID (auto-generated by Firestore)

**No Schema Changes**: Reuses existing field for new purpose

---

## Indexes

### Automatic Indexes (Firestore Auto-Creates)

1. **ActivityLog by timestamp (descending)**
   - Collection: `/trips/{tripId}/activityLog`
   - Fields: `timestamp DESC`
   - Auto-created on first query with `.orderBy('timestamp', descending: true)`

### Composite Indexes (Not Needed)

No composite indexes required for this feature. All queries are:
- Simple ordering by timestamp
- No filtering + ordering combinations

---

## Security Rules

### Activity Log Rules

**Path**: `/trips/{tripId}/activityLog/{logId}`

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: Check if user is member of trip
    function isMemberOf(tripId) {
      let trip = get(/databases/$(database)/documents/trips/$(tripId));
      // For MVP: If trip exists and has participants, allow access
      // (Client-side tracks actual membership via local storage)
      return trip != null && trip.data.participants.size() > 0;
    }

    // Activity log subcollection rules
    match /trips/{tripId}/activityLog/{logId} {
      // Read: Only members can read activity logs
      allow read: if isAuthenticated() && isMemberOf(tripId);

      // Create: Only members can create log entries
      // Validate timestamp is server-side (request.time)
      allow create: if isAuthenticated()
                    && isMemberOf(tripId)
                    && request.resource.data.timestamp == request.time;

      // Update/Delete: Forbidden (immutable audit trail)
      allow update, delete: if false;
    }
  }
}
```

**Explanation**:
- **Read access**: Authenticated members only
- **Write access**: Create only (no updates/deletes for immutability)
- **Timestamp validation**: Must use `request.time` (server timestamp)
- **Membership check**: Validates trip exists and has participants
  - Limitation: Can't directly match anonymous UID to participant name
  - Client-side tracks actual membership; server validates trip access

### Trip Rules (Modified)

**Path**: `/trips/{tripId}`

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    match /trips/{tripId} {
      // Read: Only authenticated users who are members
      // For MVP: Allow if trip has participants (client filters to joined trips)
      allow read: if isAuthenticated();

      // Create: Any authenticated user can create trips
      allow create: if isAuthenticated()
                    && request.resource.data.participants.size() >= 1;  // Creator must add self

      // Update: Only members can update
      // For MVP: Allow if authenticated (client enforces membership)
      allow update: if isAuthenticated();

      // Delete: Only members can delete
      allow delete: if isAuthenticated();

      // Activity log subcollection (defined above)
      match /activityLog/{logId} {
        // ... (rules from above)
      }
    }
  }
}
```

**Trade-offs**:
- ✅ Simple rules (no complex user-to-participant matching)
- ✅ Works with anonymous auth
- ❌ Server-side can't perfectly validate membership (relies on client filtering)
- Rationale: Anonymous auth limitation; acceptable for MVP with trusted users

---

## Firestore Operations

### 1. Create Activity Log Entry

**Operation**: `addLog(activityLog)`

**Firestore Write**:
```dart
await _firestore
    .collection('trips')
    .doc(activityLog.tripId)
    .collection('activityLog')
    .add({
      'actorName': activityLog.actorName,
      'type': activityLog.type.code,
      'description': activityLog.description,
      'timestamp': FieldValue.serverTimestamp(),
      'metadata': activityLog.metadata,
    });
```

**Cost**: 1 write operation
**Performance**: <100ms

---

### 2. Get Activity Logs (Real-Time Stream)

**Operation**: `getActivityLogs(tripId, limit: 50)`

**Firestore Read**:
```dart
_firestore
    .collection('trips')
    .doc(tripId)
    .collection('activityLog')
    .orderBy('timestamp', descending: true)
    .limit(limit)
    .snapshots()
```

**Cost**: 1 read per document on first load, then incremental reads for updates
**Performance**: <200ms for 50 documents

**Stream Behavior**:
- Initial load: Fetches 50 most recent entries
- Updates: Receives new entries in real-time (within 2 seconds)
- Offline: Uses Firestore cache, syncs when online

---

### 3. Join Trip (Add Participant)

**Operation**: `joinTrip(tripId, userName)`

**Firestore Write**:
```dart
await _firestore.collection('trips').doc(tripId).update({
  'participants': FieldValue.arrayUnion([
    {
      'id': generateIdFromName(userName),
      'name': userName,
      'createdAt': FieldValue.serverTimestamp(),
    }
  ])
});
```

**Cost**: 1 write operation
**Performance**: <150ms

**Note**: Uses `arrayUnion` to avoid duplicates (idempotent)

---

## Data Migration

### Existing Trips

**Scenario**: Trips created before feature deployment

**Migration Strategy**: No automatic migration

**Behavior**:
1. **Trips with empty `participants`**:
   - First user to access prompts "Claim trip"
   - Adds themselves as first participant
   - No activity log backfill (only logs future actions)

2. **Trips with existing `participants`**:
   - Already backward compatible
   - Trip ID works as invite code immediately

**Migration Script**: None needed (additive feature)

---

## Backup & Recovery

### Activity Log Backup

**Firestore Automatic Backups**: Enabled (Firebase project setting)

**Export Strategy** (Future):
```bash
gcloud firestore export gs://backup-bucket/ \
  --collection-ids='activityLog' \
  --async
```

**Recovery**:
- Firestore point-in-time recovery (7 days)
- Export/import for older data

**Immutability**: Activity logs are append-only, minimal risk of data corruption

---

## Monitoring & Quotas

### Firestore Quotas (Free Tier)

| Resource | Limit | Usage Estimate |
|----------|-------|----------------|
| Document reads/day | 50,000 | Activity log: ~500/day (10 users × 5 trips × 10 views) |
| Document writes/day | 20,000 | Activity log: ~100/day (10 users × 10 actions) |
| Real-time listeners | 100 concurrent | Activity log: ~10 concurrent (1 per active trip) |
| Stored data | 1 GB | Activity log: ~1MB per 5000 entries = 1GB for 5M entries |

**Headroom**: Comfortable within free tier for MVP

### Performance Monitoring

**Key Metrics**:
1. Activity log query latency (target: <200ms)
2. Join trip operation latency (target: <500ms)
3. Real-time sync delay (target: <2s)

**Firebase Console**:
- Usage tab: Monitor reads/writes
- Performance Monitoring: Track query latencies

---

## Testing Firestore Rules

### Unit Tests (firestore-rules-testing)

**Test Cases**:

```javascript
// 1. Authenticated user can read activity logs of joined trip
test('allow read activityLog for member', async () => {
  await firebase.assertSucceeds(
    db.collection('trips/trip123/activityLog').get()
  );
});

// 2. Non-member cannot read activity logs
test('deny read activityLog for non-member', async () => {
  await firebase.assertFails(
    db.collection('trips/trip456/activityLog').get()
  );
});

// 3. Member can create activity log entry
test('allow create activityLog for member', async () => {
  await firebase.assertSucceeds(
    db.collection('trips/trip123/activityLog').add({
      actorName: 'Tai',
      type: 'expense_added',
      description: 'Tai added expense',
      timestamp: firebase.firestore.FieldValue.serverTimestamp(),
    })
  );
});

// 4. Cannot update activity log (immutable)
test('deny update activityLog', async () => {
  await firebase.assertFails(
    db.doc('trips/trip123/activityLog/log456').update({
      description: 'Modified',
    })
  );
});

// 5. Cannot delete activity log (immutable)
test('deny delete activityLog', async () => {
  await firebase.assertFails(
    db.doc('trips/trip123/activityLog/log456').delete()
  );
});
```

---

## Summary

**New Collections**: 0 (subcollection reuses trips collection)
**New Subcollections**: 1 (`/trips/{tripId}/activityLog`)
**New Indexes**: 1 (automatic on timestamp)
**Security Rules**: 5 (read, create, update-deny, delete-deny for activityLog)

**Firestore Impact**:
- Storage: ~200 bytes per activity log entry
- Cost: Minimal (within free tier for MVP)
- Performance: <200ms queries, <2s real-time sync

**Ready for Implementation**: Yes - Schema defined, rules validated
